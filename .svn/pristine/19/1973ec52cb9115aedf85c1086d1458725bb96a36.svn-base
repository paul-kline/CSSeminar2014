/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package TemplateMethod;

import TetrisHelpful.BoardConverter;
import TetrisHelpful.TetrisWriter;
import java.awt.Label;
import java.util.LinkedList;
import tetrispaul4.ControllerObject;
import net.percederberg.tetris.Game;
import tetris3.APlacementRecord;
import tetris3.Cenario;
import tetrispaul4.WeightSelector;
import tetris3.PlacementDecider;

/**
 *
 * @author paul.kline
 */
public class AbstractGame extends Game implements PlayingInterface {

    public ControllerObject myCO;
    protected LinkedList<byte[][]> playedBoards;
    protected LinkedList<Integer> playedPieces;
    protected LinkedList<byte[][]> futureBoards;
    protected LinkedList<Integer> futurePieces;
    public Label label;
    boolean UseNN = false;
    boolean PauseOnDiff = true;
    protected boolean careIfNNChoiceIsSameAsGChoice = true;
    protected boolean careIfHoleIsMade = true;
    protected boolean useWeights = false;
    protected boolean KeepHistory = false;
    protected int HistoryToKeepNumber = 200;
    LinkedList<APlacementRecord> placementHistory = new LinkedList<>();
    //  protected boolean ShuffleFails=false;

    public AbstractGame() {
        super();
    }

    public AbstractGame(WeightSelector w, ControllerObject co) {
        this();
        myCO = co;
        myWS = w;

    }

    @Override
    public void handleFigureStart() {
        super.handleFigureStart();

        if (!ShouldUseWeights()) {
            handleMakeDecision();
            movePiece(placementDecider);
        }
    }

    public boolean shouldKeepHistory() {
        return true;
    }

    public boolean ShouldUseWeights() {
        return useWeights;
    }

    private boolean ShouldAskNN() {
        return UseNN;
    }

    public boolean ShouldPauseOnDiff() {
        return PauseOnDiff;
    }

    @Override
    public void handleMakeDecision() {
        placementDecider = null;
        placementDecider = new PlacementDecider(board, figure, nextFigure, myCO.weights);

        if (ShouldAskNN()) {
            placementDecider.SetmyCO(myCO);
            placementDecider.MakeADecisionAndAskNNIfNotSure();
            if (ShouldPauseOnDiff() && TestPauseConditions()) {
                thread.setPaused(true);
                handlePause();
            }
        } else {
            placementDecider.MakeDecision();
        }

    }

    @Override
    public void handleFigureLandedHook() {
        if (KeepHistory) {
            // Cenario cenario = placementDecider.getBest();
            BoardConverter bc = new BoardConverter();
            APlacementRecord rememberMe = new APlacementRecord(figure.shapeshape,
                    bc.ConvertToByte_specializeCurrentFigure(board, figure, 2));
//            APlacementRecord rememberMe = new APlacementRecord(cenario.getMyfig().getType(),
//                    cenario.DuplicateBoard(cenario.getMyboardAfterPlacementBeforeLinesClearedBeforeAllOnes()));
            System.out.println("HERE IS THE BOARD i AM KEEPING!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            System.out.println((new TetrisWriter()).GetStringBoard(rememberMe.GetBoard()));
            AddBoardToHistory(rememberMe);
        }
    }

    public boolean TestPauseConditions() {
        if (getCareIfNNChoiceIsSameAsGChoice() && !placementDecider.GetIsNNChoiceSameAsG_Choice()) {
            System.out.println("should pause is true");
            return true;
        }
        if (getCareIfHoleIsMade() && placementDecider.HoleIsMade()) {
            System.out.println("Should pause is true");
            return true;
        }
        System.out.println("should pause is false");
        return false;
    }

    public boolean getCareIfNNChoiceIsSameAsGChoice() {
        return careIfNNChoiceIsSameAsGChoice;
    }

    public boolean getCareIfHoleIsMade() {
        return careIfHoleIsMade;
    }

    public void SetUseNN(Boolean UseNN) {
        this.UseNN = UseNN;
    }

    public void SetPauseOnDiff(boolean PauseOnDif) {
        PauseOnDiff = PauseOnDif;


    }

    public void setUseWeights(boolean UseWeights) {
        this.useWeights = UseWeights;
    }

    protected void AddBoardToHistory(APlacementRecord record) {
        if (placementHistory.size() >= HistoryToKeepNumber) {
            placementHistory.removeFirst();
        }
        placementHistory.add(record);

    }

    public void SetKeepHistory(boolean k, int thismany) {
        this.KeepHistory = k;
        HistoryToKeepNumber = thismany;
    }
//    public void setShuffleFails(boolean b) {
//    //    System.out.println("I am setting shuffleFails to this: "+ b);
//    //    this.ShuffleFails=b;
//    }
}
